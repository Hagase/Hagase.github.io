<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">LearnOpenGL-模型加载 | Shiroha</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "Shirohaの小矛屋";
  mashiro_option.author_name = "小矛屋";
  mashiro_option.site_url = "www.shiroha.cn";
  mashiro_option.v_appId = "wswNvhpWzQ3DPNl7W2e9u6TW-gzGzoHsz";
  mashiro_option.v_appKey = "CVFjJULlnSe9RxKSEngIk5aR";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/1.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/2.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/3.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/4.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/5.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/6.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/7.png,https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/8.png".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="www.shiroha.cn">
          <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>这里是Shirohaの小矛屋，B站UP主矛盾钢琴师。</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/hagase" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://weibo.com/5641766727/profile" target="_blank" class="social-github" title="sina">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/sina.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://music.163.com/#/user/home?id=82156482" target="_blank" class="social-github" title="wangyiyun">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/wangyiyun.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/mao-dun-gang-qin-shi-58/activities" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://weibo.com/mashirozx?is_all=1" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">Shirohaの</span>
            <span class="shironeko">小矛屋</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/技术/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/生活/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/随想/">
                          <i class="fa fa-commenting-o" aria-hidden="true"></i>
                          随想
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/转载/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    清单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          书单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          番组
                        </a>
                      </li>
                    
                      <li>
                        <a href="/music/">
                          <i class="fa fa-headphones" aria-hidden="true"></i>
                          歌单
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/图集/">
                          <i class="fa fa-photo" aria-hidden="true"></i>
                          图集
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    友人帐
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                      <li>
                        <a href="/theme-sakura/">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Lab
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/3.png);" src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/3.png">
    </div>
    <header class="pattern-header single-header">
      <h1 class="entry-title">
      LearnOpenGL-模型加载</h1>
      <p class="entry-census">
        <span>
          <a href="www.shiroha.cn">
            <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="www.shiroha.cn">Shiroha</a>
        </span>
        <span class="bull">
        ·</span>
        2019-10-7<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <p>@[toc]</p>
<h1 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h1><p>Assimp数据结构的（简化）模型如下：<br><img src="https://img-blog.csdnimg.cn/20190924211850636.png" alt="在这里插入图片描述"></p>
<ul>
<li>和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中.Scene对象也包含了场景根节点的引用.</li>
<li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引.Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引.</li>
<li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质.</li>
<li>一个网格包含了多个面.Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）.一个面包含了组成图元的顶点的索引.由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的.</li>
<li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）.</li>
</ul>
<p>所以，我们需要做的第一件事是将一个物体加载到Scene对象中，<strong>遍历节点</strong>，获取对应的Mesh对象（我们需要<strong>递归搜索</strong>每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性.最终的结果是一系列的<strong>网格数据</strong>，我们会将它们包含在一个Model对象中.</p>
<blockquote>
<p><strong>网格</strong><br>当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型.通常每个模型都由几个子模型/形状组合而成.组合模型的每个单独的形状就叫做一个网格(Mesh).比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）.一个模型（通常）会包括多个网格.</p>
</blockquote>
<h2 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h2><p>首先我们来回顾一下我们目前学到的知识，想想一个网格最少需要什么数据.一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量.一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）.</p>
<p>既然我们有了一个网格类的最低需求，我们可以在OpenGL中定义一个顶点了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将所有需要的向量储存到一个叫做Vertex的结构体中，我们可以用它来索引每个顶点属性.除了Vertex结构体之外，我们还需要将纹理数据整理到一个Texture结构体中.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们储存了纹理的id以及它的类型，比如是漫反射贴图或者是镜面光贴图.</p>
<p>知道了顶点和纹理的实现，我们可以开始定义网格类的结构了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  网格数据  */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        Mesh(<span class="built_in">vector</span>&lt;Vertex&gt; vertices, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices, <span class="built_in">vector</span>&lt;Texture&gt; textures);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  渲染数据  */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO, EBO;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setupMesh</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将所有必须的数据赋予了网格，我们在setupMesh函数中初始化缓冲，并最终使用Draw函数来绘制网格.注意我们将一个着色器传入了Draw函数中，将着色器传入网格类中可以让我们在绘制之前设置一些uniform（像是链接采样器到纹理单元）.</p>
<p>Mesh构造函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mesh(<span class="built_in">vector</span>&lt;Vertex&gt; vertices, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices, <span class="built_in">vector</span>&lt;Texture&gt; textures)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;vertices = vertices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">    <span class="keyword">this</span>-&gt;textures = textures;</span><br><span class="line"></span><br><span class="line">    setupMesh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>由于有了构造器，我们现在有一大列的网格数据用于渲染.在此之前我们还必须配置正确的缓冲，并通过顶点属性指针定义顶点着色器的布局.现在你应该对这些概念都很熟悉了，但我们这次会稍微有一点变动，使用结构体中的顶点数据：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupMesh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="keyword">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);  </span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), </span><br><span class="line">                 &amp;indices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点位置</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);   </span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 顶点法线</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);   </span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, Normal));</span><br><span class="line">    <span class="comment">// 顶点纹理坐标</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">2</span>);   </span><br><span class="line">    glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, TexCoords));</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++结构体有一个很棒的特性，它们的内存布局是连续的(Sequential).也就是说，如果我们将结构体作为一个数据数组使用，那么它将会以顺序排列结构体的变量，这将会直接转换为我们在数组缓冲中所需要的float（实际上是字节）数组.比如说，如果我们有一个填充后的Vertex结构体，那么它的内存布局将会等于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vertex vertex;</span><br><span class="line">vertex.Position  = glm::vec3(<span class="number">0.2f</span>, <span class="number">0.4f</span>, <span class="number">0.6f</span>);</span><br><span class="line">vertex.Normal    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertex.TexCoords = glm::vec2(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];</span></span><br></pre></td></tr></table></figure>
<p>由于有了这个有用的特性，我们能够直接传入一大列的Vertex结构体的指针作为缓冲的数据，它们将会完美地转换为glBufferData所能用的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="keyword">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>自然sizeof运算也可以用在结构体上来计算它的字节大小.这个应该是32字节的（8个float * 每个4字节）.</p>
<p>结构体的另外一个很好的用途是它的<strong>预处理指令offsetof(s, m)</strong>，它的第一个参数是一个<strong>结构体</strong>，第二个参数是这个结构体中<strong>变量的名字</strong>.这个宏会<strong>返回那个变量距结构体头部的字节偏移量(Byte Offset)</strong>.这正好可以用在定义glVertexAttribPointer函数中的偏移参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), (<span class="keyword">void</span>*)offsetof(Vertex, Normal));</span><br></pre></td></tr></table></figure>
<p>偏移量现在是使用offsetof来定义了，在这里它会将法向量的字节偏移量设置为结构体中法向量的偏移量，也就是3个float，即12字节.注意，我们同样将步长参数设置为了Vertex结构体的大小.</p>
<p>使用这样的一个结构体不仅能够提供<strong>可读性更高</strong>的代码，也允许我们很容易地<strong>拓展</strong>这个结构.如果我们希望添加另一个顶点属性，我们只需要将它添加到结构体中就可以了.由于它的<strong>灵活性</strong>，渲染的代码<strong>不会被破坏</strong>.</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>我们需要为Mesh类定义最后一个函数，它的Draw函数.在真正渲染这个网格之前，我们需要在调用glDrawElements函数之前先绑定相应的纹理.然而，这实际上有些困难，我们一开始并不知道这个网格（如果有的话）有多少纹理、纹理是什么类型的.所以我们该如何在着色器中设置纹理单元和采样器呢？</p>
<p>为了解决这个问题，我们需要设定一个命名标准：每个<strong>漫反射纹理</strong>被命名为<strong>texture_diffuseN</strong>，每个<strong>镜面光纹理</strong>应该被命名为<strong>texture_specularN</strong>，其中<strong>N的范围是1到纹理采样器最大允许的数字</strong>.比如说我们对某一个网格有3个漫反射纹理，2个镜面光纹理，它们的纹理采样器应该之后会被调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uniform sampler2D texture_diffuse1;</span><br><span class="line">uniform sampler2D texture_diffuse2;</span><br><span class="line">uniform sampler2D texture_diffuse3;</span><br><span class="line">uniform sampler2D texture_specular1;</span><br><span class="line">uniform sampler2D texture_specular2;</span><br></pre></td></tr></table></figure>
<p>根据这个标准，我们可以在着色器中定义任意需要数量的纹理采样器，如果一个网格真的包含了（这么多）纹理，我们也能知道它们的名字是什么.根据这个标准，我们也能在一个网格中处理任意数量的纹理，开发者也可以自由选择需要使用的数量，他只需要定义正确的采样器就可以了（虽然定义少的话会有点浪费绑定和uniform调用）.</p>
<p>最终的渲染代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; textures.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        glActiveTexture(GL_TEXTURE0 + i); <span class="comment">// 在绑定之前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></span><br><span class="line">        <span class="built_in">string</span> number;</span><br><span class="line">        <span class="built_in">string</span> name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">"texture_diffuse"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(name == <span class="string">"texture_specular"</span>)</span><br><span class="line">            number = <span class="built_in">std</span>::to_string(specularNr++);</span><br><span class="line"></span><br><span class="line">        shader.setFloat((<span class="string">"material."</span> + name + number).c_str(), i);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    glActiveTexture(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先计算了每个纹理类型的N-分量，并将其拼接到纹理类型字符串上，来获取对应的uniform名称.接下来我们查找对应的采样器，将它的位置值设置为当前激活的纹理单元，并绑定纹理.这也是我们在Draw函数中需要着色器的原因.我们也将”material.”添加到了最终的uniform名称中，因为我们希望将纹理储存在一个材质结构体中（这在每个实现中可能都不同）.</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>这一节我们会使用Assimp来加载模型，并将它转换(Translate)至多个在上一节中创建的Mesh对象.<br>Model的定义如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        Model(<span class="keyword">char</span> *path)</span><br><span class="line">        &#123;</span><br><span class="line">            loadModel(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;   </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  模型数据  */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Mesh&gt; meshes;</span><br><span class="line">        <span class="built_in">string</span> directory;</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadModel</span><span class="params">(<span class="built_in">string</span> path)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="keyword">const</span> aiScene *scene)</span></span>;</span><br><span class="line">        <span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh *mesh, <span class="keyword">const</span> aiScene *scene)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, </span><br><span class="line">                                             <span class="built_in">string</span> typeName);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Model类包含了一个Mesh对象的vector，构造器需要我们给它一个文件路径.在构造器中，它会直接通过loadModel来加载文件.私有函数将会处理Assimp导入过程中的一部分，我们很快就会介绍它们.我们还将储存文件路径的目录，在之后加载纹理的时候还会用到它.</p>
<p>Draw函数没有什么特别之处，基本上就是遍历了所有网格，并调用它们各自的Draw函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; meshes.size(); i++)</span><br><span class="line">        meshes[i].Draw(shader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="导入3D模型到OpenGL"><a href="#导入3D模型到OpenGL" class="headerlink" title="导入3D模型到OpenGL"></a>导入3D模型到OpenGL</h2><p>要想导入一个模型，并将它转换到我们自己的数据结构中的话，首先我们需要包含Assimp对应的头文件，这样编译器就不会抱怨我们了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/Importer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/scene.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assimp/postprocess.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>首先需要调用的函数是loadModel，它会从构造器中直接调用.在loadModel中，我们使用Assimp来加载模型至Assimp的一个叫做scene的数据结构中.你可能还记得在模型加载章节的第一节教程中，这是Assimp数据接口的根对象.一旦我们有了这个场景对象，我们就能访问到加载后的模型中所有所需的数据了.</p>
<p>Assimp很棒的一点在于，它抽象掉了加载不同文件格式的所有技术细节，只需要一行代码就能完成所有的工作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Assimp::Importer importer;</span><br><span class="line"><span class="keyword">const</span> aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br></pre></td></tr></table></figure>
<p>我们首先声明了Assimp命名空间内的一个Importer，之后调用了它的<strong>ReadFile</strong>函数.这个函数需要一个<strong>文件路径</strong>，它的第二个参数是一些<strong>后期处理(Post-processing)的选项</strong>。除了加载文件之外，Assimp允许我们设定一些选项来强制它对导入的数据做一些额外的计算或操作。通过设定<strong>aiProcess_Triangulate</strong>，我们告诉Assimp，如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形.<strong>aiProcess_FlipUVs</strong>将在处理的时候<strong>翻转y轴的纹理坐标</strong>（你可能还记得我们在纹理教程中说过，在OpenGL中大部分的图像的y轴都是反的，所以这个后期处理选项将会修复这个）.其它一些比较有用的选项有：</p>
<ul>
<li><strong>aiProcess_GenNormals</strong>：如果模型不包含法向量的话，就为每个顶点创建法线.</li>
<li><strong>aiProcess_SplitLargeMeshes</strong>：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用.</li>
<li><strong>aiProcess_OptimizeMeshes</strong>：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化.</li>
</ul>
<p>Assimp提供了很多有用的后期处理指令，你可以在<a href="http://assimp.sourceforge.net/lib_html/postprocess_8h.html" target="_blank" rel="noopener">这里</a>找到全部的指令.实际上使用Assimp加载模型是非常容易的（你也可以看到）.困难的是之后使用返回的场景对象将加载的数据转换到一个Mesh对象的数组.</p>
<p>完整的loadModel函数将会是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadModel</span><span class="params">(<span class="built_in">string</span> path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assimp::Importer <span class="keyword">import</span>;</span><br><span class="line">    <span class="keyword">const</span> aiScene *scene = <span class="keyword">import</span>.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::ASSIMP::"</span> &lt;&lt; <span class="keyword">import</span>.GetErrorString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    directory = path.substr(<span class="number">0</span>, path.find_last_of(<span class="string">'/'</span>));</span><br><span class="line"></span><br><span class="line">    processNode(scene-&gt;mRootNode, scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们加载了模型之后，我们会检查场景和其根节点不为<strong>null</strong>，并且检查了它的一个标记(Flag)，来查看返回的数据是不是不完整的.如果遇到了任何错误，我们都会通过导入器的<strong>GetErrorString</strong>函数来报告错误并返回.我们也获取了文件路径的目录路径.</p>
<p>如果什么错误都没有发生，我们希望处理场景中的所有节点，所以我们将第一个节点（根节点）传入了<strong>递归</strong>的<strong>processNode</strong>函数.因为每个节点（可能）包含有多个子节点，我们希望首先处理参数中的节点，再继续处理该节点所有的子节点，以此类推.这正符合一个递归结构，所以我们将定义一个递归函数.递归函数在做一些处理之后，使用不同的参数递归调用这个函数自身，直到某个条件被满足停止递归.在我们的例子中退出条件(Exit Condition)是所有的节点都被处理完毕。</p>
<p>你可能还记得Assimp的结构中，每个节点包含了一系列的网格索引，每个索引指向场景对象中的那个特定网格.我们接下来就想去获取这些网格索引，获取每个网格，处理每个网格，接着对每个节点的子节点重复这一过程。processNode函数的内容如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="keyword">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理节点所有的网格（如果有的话）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; </span><br><span class="line">        meshes.push_back(processMesh(mesh, scene));         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来对它的子节点重复这一过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        processNode(node-&gt;mChildren[i], scene);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们首先检查每个节点的网格索引，并索引场景的mMeshes数组来获取对应的网格.返回的网格将会传递到processMesh函数中，它会返回一个Mesh对象，我们可以将它存储在meshes列表/vector.</p>
<p>所有网格都被处理之后，我们会遍历节点的所有子节点，并对它们调用相同的processMesh函数.当一个节点不再有任何子节点之后，这个函数将会停止执行.</p>
<blockquote>
<p>认真的读者可能会发现，我们可以基本上忘掉处理任何的节点，只需要遍历场景对象的所有网格，就不需要为了索引做这一堆复杂的东西了.我们仍这么做的原因是，使用节点的最初想法是将网格之间定义一个父子关系.通过这样递归地遍历这层关系，我们就能将某个网格定义为另一个网格的父网格了.<br>这个系统的一个使用案例是，当你想位移一个汽车的网格时，你可以保证它的所有子网格（比如引擎网格、方向盘网格、轮胎网格）都会随着一起位移。这样的系统能够用父子关系很容易地创建出来.<br>然而，现在我们并没有使用这样一种系统，但如果你想对你的网格数据有更多的控制，通常都是建议使用这一种方法的。这种类节点的关系毕竟是由创建了这个模型的艺术家所定义.</p>
</blockquote>
<h2 id="从Assimp到网格"><a href="#从Assimp到网格" class="headerlink" title="从Assimp到网格"></a>从Assimp到网格</h2><p>将一个aiMesh对象转化为我们自己的网格对象不是那么困难.我们要做的只是访问网格的相关属性并将它们储存到我们自己的对象中.processMesh函数的大体结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh *mesh, <span class="keyword">const</span> aiScene *scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Vertex&gt; vertices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex vertex;</span><br><span class="line">        <span class="comment">// 处理顶点位置、法线和纹理坐标</span></span><br><span class="line">        ...</span><br><span class="line">        vertices.push_back(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理索引</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理材质</span></span><br><span class="line">    <span class="keyword">if</span>(mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mesh(vertices, indices, textures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理网格的过程主要有三部分：获取所有的顶点数据，获取它们的网格索引，并获取相关的材质数据.处理后的数据将会储存在三个vector当中，我们会利用它们构建一个Mesh对象，并返回它到函数的调用者那里.</p>
<p>获取顶点数据非常简单，我们定义了一个Vertex结构体，我们将在每个迭代之后将它加到vertices数组中.我们会遍历网格中的所有顶点（使用mesh-&gt;mNumVertices来获取）.在每个迭代中，我们希望使用所有的相关数据填充这个结构体。顶点的位置是这样处理的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glm::vec3 <span class="built_in">vector</span>; </span><br><span class="line"><span class="built_in">vector</span>.x = mesh-&gt;mVertices[i].x;</span><br><span class="line"><span class="built_in">vector</span>.y = mesh-&gt;mVertices[i].y;</span><br><span class="line"><span class="built_in">vector</span>.z = mesh-&gt;mVertices[i].z; </span><br><span class="line">vertex.Position = <span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>注意我们为了传输Assimp的数据，我们定义了一个vec3的临时变量.使用这样一个临时变量的原因是Assimp对向量、矩阵、字符串等都有自己的一套数据类型，它们并不能完美地转换到GLM的数据类型中.</p>
<blockquote>
<p>Assimp将它的顶点位置数组叫做mVertices，这其实并不是那么直观.</p>
</blockquote>
<p>处理法线的步骤也是差不多的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>.x = mesh-&gt;mNormals[i].x;</span><br><span class="line"><span class="built_in">vector</span>.y = mesh-&gt;mNormals[i].y;</span><br><span class="line"><span class="built_in">vector</span>.z = mesh-&gt;mNormals[i].z;</span><br><span class="line">vertex.Normal = <span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>纹理坐标的处理也大体相似，但Assimp允许一个模型在一个顶点上有最多8个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标.我们同样也想检查网格是否真的包含了纹理坐标（可能并不会一直如此）.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mesh-&gt;mTextureCoords[<span class="number">0</span>]) <span class="comment">// 网格是否有纹理坐标？</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec2 vec;</span><br><span class="line">    vec.x = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].x; </span><br><span class="line">    vec.y = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].y;</span><br><span class="line">    vertex.TexCoords = vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    vertex.TexCoords = glm::vec2(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure>
<p>vertex结构体现在已经填充好了需要的顶点属性，我们会在迭代的最后将它压入vertices这个vector的尾部.这个过程会对每个网格的顶点都重复一遍.</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Assimp的接口定义了每个网格都有一个面(Face)数组，每个面代表了一个图元，在我们的例子中（由于使用了<strong>aiProcess_Triangulate</strong>选项）它总是三角形.一个面包含了多个索引，它们定义了在每个图元中，我们应该绘制哪个顶点，并以什么顺序绘制，所以如果我们遍历了所有的面，并储存了面的索引到indices这个vector中就可以了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumFaces; i++)</span><br><span class="line">&#123;</span><br><span class="line">    aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; face.mNumIndices; j++)</span><br><span class="line">        indices.push_back(face.mIndices[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的外部循环都结束了，我们现在有了一系列的顶点和索引数据，它们可以用来通过glDrawElements函数来绘制网格.然而，为了结束这个话题，并且对网格提供一些细节，我们还需要处理网格的材质.</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>和节点一样，一个网格只包含了一个指向材质对象的索引.如果想要获取网格真正的材质，我们还需要索引场景的mMaterials数组.网格材质索引位于它的mMaterialIndex属性中，我们同样可以用它来检测一个网格是否包含有材质：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    aiMaterial *material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, </span><br><span class="line">                                        aiTextureType_DIFFUSE, <span class="string">"texture_diffuse"</span>);</span><br><span class="line">    textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; specularMaps = loadMaterialTextures(material, </span><br><span class="line">                                        aiTextureType_SPECULAR, <span class="string">"texture_specular"</span>);</span><br><span class="line">    textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先从场景的mMaterials数组中获取aiMaterial对象.接下来我们希望加载网格的漫反射和/或镜面光贴图.一个材质对象的内部对每种纹理类型都存储了一个纹理位置数组.不同的纹理类型都以aiTextureType_为前缀.我们使用一个叫做loadMaterialTextures的工具函数来从材质中获取纹理.这个函数将会返回一个Texture结构体的vector，我们将在模型的textures vector的尾部之后存储它.</p>
<p>loadMaterialTextures函数遍历了给定纹理类型的所有纹理位置，获取了纹理的文件位置，并加载并和生成了纹理，将信息储存在了一个Vertex结构体中。它看起来会像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="built_in">string</span> typeName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;GetTextureCount(type); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiString str;</span><br><span class="line">        mat-&gt;GetTexture(type, i, &amp;str);</span><br><span class="line">        Texture texture;</span><br><span class="line">        texture.id = TextureFromFile(str.C_Str(), directory);</span><br><span class="line">        texture.type = typeName;</span><br><span class="line">        texture.path = str;</span><br><span class="line">        textures.push_back(texture);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先通过GetTextureCount函数检查储存在材质中纹理的数量，这个函数需要一个纹理类型。我们会使用GetTexture获取每个纹理的文件位置，它会将结果储存在一个aiString中.我们接下来使用另外一个叫做TextureFromFile的工具函数，它将会（用stb_image.h）加载一个纹理并返回该纹理的ID.</p>
<blockquote>
<p>注意，我们假设了模型文件中纹理文件的路径是相对于模型文件的本地(Local)路径，比如说与模型文件处于同一目录下.我们可以将纹理位置字符串拼接到之前（在loadModel中）获取的目录字符串上，来获取完整的纹理路径（这也是为什么GetTexture函数也需要一个目录字符串）.<br>在网络上找到的某些模型会对纹理位置使用绝对(Absolute)路径，这就不能在每台机器上都工作了。在这种情况下，你可能会需要手动修改这个文件，来让它对纹理使用本地路径（如果可能的话）.</p>
</blockquote>
<h2 id="重大优化"><a href="#重大优化" class="headerlink" title="重大优化"></a>重大优化</h2><p>大多数场景都会在多个网格中重用部分纹理.还是想想一个房子，它的墙壁有着花岗岩的纹理.这个纹理也可以被应用到地板、天花板、楼梯、桌子，甚至是附近的一口井上.加载纹理并不是一个开销不大的操作，在我们当前的实现中，即便同样的纹理已经被加载过很多遍了，对每个网格仍会加载并生成一个新的纹理.这很快就会变成模型加载实现的性能瓶颈.</p>
<p>所以我们会对模型的代码进行调整，将所有加载过的纹理全局储存，每当我们想加载一个纹理的时候，首先去检查它有没有被加载过.如果有的话，我们会直接使用那个纹理，并跳过整个加载流程，来为我们省下很多处理能力.为了能够比较纹理，我们还需要储存它们的路径：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Texture</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> type;</span><br><span class="line">    aiString path;  <span class="comment">// 我们储存纹理的路径用于与其它纹理进行比较</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们将所有加载过的纹理储存在另一个vector中，在模型类的顶部声明为一个私有变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Texture&gt; textures_loaded;</span><br></pre></td></tr></table></figure>
<p>之后，在loadMaterialTextures函数中，我们希望将纹理的路径与储存在textures_loaded这个vector中的所有纹理进行比较，看看当前纹理的路径是否与其中的一个相同.如果是的话，则跳过纹理加载/生成的部分，直接使用定位到的纹理结构体为网格的纹理.更新后的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="built_in">string</span> typeName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Texture&gt; textures;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;GetTextureCount(type); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        aiString str;</span><br><span class="line">        mat-&gt;GetTexture(type, i, &amp;str);</span><br><span class="line">        <span class="keyword">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; textures_loaded.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">strcmp</span>(textures_loaded[j].path.data(), str.C_Str()) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                textures.push_back(textures_loaded[j]);</span><br><span class="line">                skip = <span class="literal">true</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!skip)</span><br><span class="line">        &#123;   <span class="comment">// 如果纹理还没有被加载，则加载它</span></span><br><span class="line">            Texture texture;</span><br><span class="line">            texture.id = TextureFromFile(str.C_Str(), directory);</span><br><span class="line">            texture.type = typeName;</span><br><span class="line">            texture.path = str.C_Str();</span><br><span class="line">            textures.push_back(texture);</span><br><span class="line">            textures_loaded.push_back(texture); <span class="comment">// 添加到已加载的纹理中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        <!-- .entry-content -->
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2019/10/07/动漫语录收集/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/2.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/2.png">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                动漫语录收集</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2019/10/07/LearnOpenGL-光照/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/2.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/cover/2.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                LearnOpenGL-光照</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "wswNvhpWzQ3DPNl7W2e9u6TW-gzGzoHsz",
        appKey: "CVFjJULlnSe9RxKSEngIk5aR",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <a href="www.shiroha.cn" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/custom/avatar.jpg" itemprop="image" alt="Shiroha" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="www.shiroha.cn" itemprop="url" rel="author">Shiroha</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>Shiroha</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Shiroha<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1","name":"summer.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1","name":"summer.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/hagase/shiroha_cdn@1.1/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">Shirohaの小矛屋</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/hagase" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://weibo.com/5641766727/profile" class="fa fa-weibo" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/技术/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/生活/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/随想/">
                  <i class="fa fa-commenting-o" aria-hidden="true"></i>
                  随想
                </a>
              </li>
            
              <li>
                <a href="/categories/转载/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            清单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  书单
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  番组
                </a>
              </li>
            
              <li>
                <a href="/music/">
                  <i class="fa fa-headphones" aria-hidden="true"></i>
                  歌单
                </a>
              </li>
            
              <li>
                <a href="/tags/图集/">
                  <i class="fa fa-photo" aria-hidden="true"></i>
                  图集
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            友人帐
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
              <li>
                <a href="/theme-sakura/">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Lab
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<div class="aplayer"

    data-id="311465842"

    data-server="netease"

    data-type="playlist"

    data-fixed="true"

    data-autoplay="false"

    data-loop="all"

    data-order="random"

    data-preload="auto"

    data-volume="0.7"

    data-mutex="true"

</div>
<script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>